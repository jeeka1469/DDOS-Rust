use std::collections::{HashMap, VecDeque};
use std::net::IpAddr;
use std::sync::Mutex;
use std::time::SystemTime;
use std::io::{self, Write};

use pnet::datalink::{self, Channel::Ethernet};
use pnet::packet::{Packet, ip::IpNextHeaderProtocols};
use pnet::packet::ipv4::Ipv4Packet;
use pnet::packet::tcp::TcpPacket;
use pnet::packet::udp::UdpPacket;

use serde::Serialize;
use csv;
use lazy_static::lazy_static;

mod model_predictor;
mod ddos_detector;
mod error;
use model_predictor::ModelPredictor;
use ddos_detector::DDoSDetector;
use error::{DDoSError, Result};

// Create a global DDoS detector
lazy_static! {
    static ref DDOS_DETECTOR: Mutex<DDoSDetector> = Mutex::new(DDoSDetector::new(60, 100)); // 100 requests per minute threshold
}

// --- Feature Struct (ALL 84+ fields) ---
#[derive(Debug, Serialize, Default, Clone)]
pub struct FlowFeatures {
    // Basic 5-tuple
    pub src_ip: String,
    pub dst_ip: String,
    pub src_port: u16,
    pub dst_port: u16,
    pub protocol: i64,
    pub timestamp: String,

    // Flow stats
    pub flow_duration: f64,
    pub flow_byts_s: f64,
    pub flow_pkts_s: f64,
    pub fwd_pkts_s: f64,
    pub bwd_pkts_s: f64,
    pub tot_fwd_pkts: u32,
    pub tot_bwd_pkts: u32,
    pub totlen_fwd_pkts: u32,
    pub totlen_bwd_pkts: u32,
    pub fwd_pkt_len_max: u32,
    pub fwd_pkt_len_min: u32,
    pub fwd_pkt_len_mean: f64,
    pub fwd_pkt_len_std: f64,
    pub bwd_pkt_len_max: u32,
    pub bwd_pkt_len_min: u32,
    pub bwd_pkt_len_mean: f64,
    pub bwd_pkt_len_std: f64,
    pub pkt_len_max: u32,
    pub pkt_len_min: u32,
    pub pkt_len_mean: f64,
    pub pkt_len_std: f64,
    pub pkt_len_var: f64,
    pub fwd_header_len: u32,
    pub bwd_header_len: u32,
    pub fwd_seg_size_min: u32,
    pub fwd_act_data_pkts: u32,
    pub flow_iat_mean: f64,
    pub flow_iat_max: f64,
    pub flow_iat_min: f64,
    pub flow_iat_std: f64,
    pub fwd_iat_tot: f64,
    pub fwd_iat_max: f64,
    pub fwd_iat_min: f64,
    pub fwd_iat_mean: f64,
    pub fwd_iat_std: f64,
    pub bwd_iat_tot: f64,
    pub bwd_iat_max: f64,
    pub bwd_iat_min: f64,
    pub bwd_iat_mean: f64,
    pub bwd_iat_std: f64,
    pub fwd_psh_flags: u8,
    pub bwd_psh_flags: u8,
    pub fwd_urg_flags: u8,
    pub bwd_urg_flags: u8,
    pub fin_flag_cnt: u8,
    pub syn_flag_cnt: u8,
    pub rst_flag_cnt: u8,
    pub psh_flag_cnt: u8,
    pub ack_flag_cnt: u8,
    pub urg_flag_cnt: u8,
    pub ece_flag_cnt: u8,
    pub down_up_ratio: f64,
    pub pkt_size_avg: f64,
    pub init_fwd_win_byts: u16,
    pub init_bwd_win_byts: u16,
    pub active_max: f64,
    pub active_min: f64,
    pub active_mean: f64,
    pub active_std: f64,
    pub idle_max: f64,
    pub idle_min: f64,
    pub idle_mean: f64,
    pub idle_std: f64,
    pub fwd_byts_b_avg: f64,
    pub fwd_pkts_b_avg: f64,
    pub bwd_byts_b_avg: f64,
    pub bwd_pkts_b_avg: f64,
    pub fwd_blk_rate_avg: f64,
    pub bwd_blk_rate_avg: f64,
    pub fwd_seg_size_avg: f64,
    pub bwd_seg_size_avg: f64,
    pub cwr_flag_count: u8,
    pub subflow_fwd_pkts: u32,
    pub subflow_bwd_pkts: u32,
    pub subflow_fwd_byts: u32,
    pub subflow_bwd_byts: u32,
    pub label: String,
}

// --- Global Flow Table ---
lazy_static! {
    static ref FLOW_TABLE: Mutex<HashMap<String, FlowTracker>> = 
        Mutex::new(HashMap::new());
    static ref MODEL_PREDICTOR: Mutex<Option<ModelPredictor>> = 
        Mutex::new(None);
}

// --- Flow Tracker ---
struct FlowTracker {
    start_time: SystemTime,
    fwd_packets: VecDeque<PacketData>,
    bwd_packets: VecDeque<PacketData>,
    last_fwd_time: Option<SystemTime>,
    last_bwd_time: Option<SystemTime>,
    init_fwd_win: Option<u16>,
    init_bwd_win: Option<u16>,
    src_ip: IpAddr,
    dst_ip: IpAddr,
    src_port: u16,
    dst_port: u16,
    protocol: i64,
    last_prediction: Option<(String, f64)>,
    prediction_count: u32,
}

#[derive(Clone)]
struct PacketData {
    timestamp: SystemTime,
    size: usize,
    tcp_flags: Option<u8>,
    header_len: usize,
    payload_len: usize,
}

fn main() -> Result<()> {
    // Handle Ctrl+C gracefully
    use std::sync::atomic::{AtomicBool, Ordering};
    use std::sync::Arc;
    let running = Arc::new(AtomicBool::new(true));
    {
        let running = running.clone();
        if let Err(err) = ctrlc::set_handler(move || {
            println!("\nCtrl+C received, stopping capture...");
            running.store(false, Ordering::SeqCst);
            // Force flush any pending writes
            std::io::stdout().flush().unwrap_or(());
        }) {
            eprintln!("Error setting Ctrl+C handler: {}", err);
            return Err(err.into());
        }
    }
    // Initialize the model predictor
    println!("Loading trained model...");
    let model_predictor = ModelPredictor::new(
        "unified_ddos_best_model.pkl",
        "unified_ddos_best_model_scaler.pkl",
        "unified_ddos_best_model_metadata.pkl"
    )?;
    
    {
        let mut predictor = MODEL_PREDICTOR.lock()
            .map_err(|e| DDoSError::LockError(format!("Failed to acquire model predictor lock: {}", e)))?;
        *predictor = Some(model_predictor);
    }
    
    println!("Model loaded successfully!");

    // List all available interfaces
    let interfaces = datalink::interfaces();
    println!("\n==============================");
    println!("Available Network Interfaces:");
    println!("==============================");
    for (i, iface) in interfaces.iter().enumerate() {
        let ips: Vec<String> = iface.ips.iter()
            .filter_map(|ip_network| {
                if let IpAddr::V4(ipv4) = ip_network.ip() {
                    Some(ipv4.to_string())
                } else {
                    None
                }
            })
            .collect();
        println!("[{}] {} - IPs: {}", i, iface.name, if ips.is_empty() { "No IPv4 assigned".to_string() } else { ips.join(", ") });
    }
    println!("\nTip: Choose the interface with the IP matching your server (e.g., 192.168.x.x). Run as administrator for best results.");
    print!("Enter interface index to capture on: ");
    io::stdout().flush()?;
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    let index: usize = input.trim().parse()
        .map_err(|_| DDoSError::ParseError("Please enter a valid number".to_string()))?;
    if index >= interfaces.len() {
        eprintln!("Invalid interface index. Exiting.");
        return Err("Invalid interface index".into());
    }
    let interface = &interfaces[index];
    let iface_ips: Vec<String> = interface.ips.iter()
        .filter_map(|ip_network| {
            if let IpAddr::V4(ipv4) = ip_network.ip() {
                Some(ipv4.to_string())
            } else {
                None
            }
        })
        .collect();
    println!("\n[Interface Verification]");
    println!("├─ Selected: {}", interface.name);
    println!("├─ MAC Address: {}", interface.mac.map_or("Unknown".to_string(), |mac| mac.to_string()));
    // MTU not available
    println!("├─ Interface Type: {}", if !iface_ips.is_empty() { "Active" } else { "Inactive" });
    println!("├─ Flags: {}", interface.flags);
    println!("└─ IPv4 Addresses: {}", if iface_ips.is_empty() { "None assigned".to_string() } else { iface_ips.join(", ") });

    // Interface capability verification
    if iface_ips.is_empty() {
        println!("\n[!] Warning: Interface has no IPv4 address");
        println!("    - Traffic capture may be limited");
        println!("    - Consider using an interface with an IP address");
    }
    
    // Check interface status and capabilities
    println!("\n[Interface Capability Check]");
    println!("├─ Link Status: {}", if !iface_ips.is_empty() { "✓ UP" } else { "⨯ DOWN" });
    println!("├─ Broadcast: {}", if interface.is_broadcast() { "✓ Supported" } else { "⨯ Not supported" });
    println!("├─ Multicast: {}", if interface.is_multicast() { "✓ Supported" } else { "⨯ Not supported" });
    println!("├─ Point-to-Point: {}", if interface.is_point_to_point() { "✓ Yes" } else { "⨯ No" });
    println!("└─ Loopback: {}", if interface.is_loopback() { "✓ Yes" } else { "⨯ No" });

    // Verify interface is ready for capture
    if iface_ips.is_empty() {
        println!("\n[!] Critical: Interface does not have an IPv4 address");
        println!("    - No traffic can be captured without a valid IPv4 address");
        println!("    - Ensure interface is connected and has a valid IP");
        println!("    - Common solutions:");
        println!("      1. Check network connection");
        println!("      2. Verify DHCP is working");
        println!("      3. Configure a static IP");
        println!("      4. Select a different interface");
        return Err("Interface has no IPv4 address".into());
    }

    // Additional warnings based on interface type
    if interface.is_loopback() {
        println!("\n[!] Notice: Loopback interface selected");
        println!("    - Will only capture local traffic");
        println!("    - For network traffic, select a network interface");
    }
    
    // Enhanced network interface configuration
    println!("\n[*] Configuring network interface for maximum packet capture...");
    let mut config = datalink::Config::default();
    config.promiscuous = true;  // Enable promiscuous mode
    config.read_timeout = Some(std::time::Duration::from_millis(1));  // Fast read timeout
    config.write_timeout = Some(std::time::Duration::from_millis(1)); // Fast write timeout
    config.read_buffer_size = 16777216;  // 16MB read buffer
    config.write_buffer_size = 16777216; // 16MB write buffer

    println!("[+] Interface settings:");
    println!("    - Promiscuous mode: Enabled");
    println!("    - Buffer size: 16MB");
    println!("    - Read timeout: 1ms");
    // MTU not available

    let (_, mut rx) = match datalink::channel(interface, config) {
        Ok(Ethernet(_, rx)) => {
            println!("[+] Successfully opened network channel in promiscuous mode");
            ((), rx)
        },
        Err(e) => {
            eprintln!("\n[!] Failed to open channel: {}", e);
            eprintln!("[!] Common solutions:");
            eprintln!("    1. Run as administrator/root");
            eprintln!("    2. Check interface permissions");
            eprintln!("    3. Verify WinPcap/Npcap installation");
            eprintln!("    4. Try a different interface");
            return Err(DDoSError::from(e));
        }
        _ => {
            eprintln!("\n[!] Failed to open channel: Unknown error");
            return Err("Failed to open channel".into());
        }
    };
    println!("\nCapturing on {}... Press Ctrl+C to stop", interface.name);
    println!("Real-time DDoS detection enabled!\n");

    // Initialize CSV writer
    let mut writer = csv::Writer::from_path("flow_features_with_predictions.csv")?;
    let mut packet_count = 0;

    let mut last_packet_time = std::time::Instant::now();
    let mut last_stats_time = std::time::Instant::now();
    let mut packets_since_last_stats = 0;
    let mut dropped_packets = 0;
    
    // Detailed packet statistics
    let mut protocol_stats = std::collections::HashMap::new();
    let mut size_distribution = std::collections::HashMap::new();
    let mut packets_per_second = Vec::new();
    let mut max_packet_rate = 0.0;
    let mut min_packet_rate = f64::MAX;
    let mut total_bytes = 0u64;
    
    // Health monitoring
    let mut capture_health = 100.0;
    
    println!("\n[*] Starting packet capture...");
    println!("[*] Packet processing statistics will be shown every 5 seconds");
    
    while running.load(Ordering::SeqCst) {
        match rx.next() {
            Ok(packet) => {
                last_packet_time = std::time::Instant::now();
                if !running.load(Ordering::SeqCst) {
                    println!("\n[*] Shutting down gracefully...");
                    break;
                }
                
                packet_count += 1;
                packets_since_last_stats += 1;

                // Process packet
                if let Some(ipv4) = Ipv4Packet::new(packet) {
                    let src_ip = ipv4.get_source();
                    let dst_ip = ipv4.get_destination();
                    let protocol_num = ipv4.get_next_level_protocol();
                    let packet_size = packet.len();
                    total_bytes += packet_size as u64;
                    
                    // Protocol name lookup and statistics
                    let proto_name = match protocol_num.0 {
                        1 => "ICMP",
                        6 => "TCP",
                        17 => "UDP",
                        47 => "GRE",
                        50 => "ESP",
                        51 => "AH",
                        58 => "ICMPv6",
                        _ => "Unknown"
                    };
                    
                    // Update protocol statistics
                    *protocol_stats.entry(proto_name.to_string()).or_insert(0) += 1;
                    
                    // Update size distribution
                    let size_category = match packet_size {
                        0..=64 => "Tiny (0-64)",
                        65..=256 => "Small (65-256)",
                        257..=1024 => "Medium (257-1024)",
                        1025..=1500 => "Large (1025-1500)",
                        _ => "Jumbo (1500+)"
                    };
                    *size_distribution.entry(size_category.to_string()).or_insert(0) += 1;

                    // Packet verification
                    let packet_valid = verify_packet(&ipv4);
                    if !packet_valid {
                        dropped_packets += 1;
                        capture_health -= 0.1;
                        capture_health = f64::max(capture_health, 0.0);
                    }

                    // Colored output based on protocol
                    let color_code = match proto_name {
                        "TCP" => "\x1b[36m",   // Cyan
                        "UDP" => "\x1b[32m",   // Green
                        "ICMP" => "\x1b[33m",  // Yellow
                        _ => "\x1b[37m"        // White
                    };
                    
                    println!("{}[Packet {:>6}] {} ({:>3}) | Src: {:>15} | Dst: {:>15} | Size: {:>4} bytes{}", 
                        color_code, packet_count, proto_name, protocol_num.0, 
                        src_ip.to_string(), dst_ip.to_string(), 
                        packet_size, "\x1b[0m");
                        
                    // Log suspicious patterns
                    if packet_size == 0 {
                        println!("\x1b[33m[!] Warning: Zero-length packet detected\x1b[0m");
                    }
                    if src_ip == dst_ip {
                        println!("\x1b[33m[!] Warning: Source IP equals Destination IP\x1b[0m");
                    }
                    match protocol_num {
                        IpNextHeaderProtocols::Tcp => {
                            if let Some(tcp) = TcpPacket::new(ipv4.payload()) {
                                process_tcp_packet(&ipv4, &tcp, &mut writer)?;
                            }
                        }
                        IpNextHeaderProtocols::Udp => {
                            if let Some(udp) = UdpPacket::new(ipv4.payload()) {
                                process_udp_packet(&ipv4, &udp, &mut writer)?;
                            }
                        }
                        _ => {
                            process_generic_packet(&ipv4, protocol_num, &mut writer)?;
                        }
                    }
                }

                // Show statistics every 5 seconds
                if last_stats_time.elapsed().as_secs() >= 5 {
                    let elapsed = last_stats_time.elapsed().as_secs_f64();
                    let pps = packets_since_last_stats as f64 / elapsed;
                    packets_per_second.push(pps);
                    max_packet_rate = f64::max(max_packet_rate, pps);
                    min_packet_rate = f64::min(min_packet_rate, pps);
                    
                    println!("\n\x1b[1m[Capture Statistics]\x1b[0m");
                    println!("├─ Packet Summary:");
                    println!("│  ├─ Total Processed: {}", packet_count);
                    println!("│  ├─ Current Rate: {:.2} pkts/sec", pps);
                    println!("│  ├─ Peak Rate: {:.2} pkts/sec", max_packet_rate);
                    println!("│  ├─ Minimum Rate: {:.2} pkts/sec", min_packet_rate);
                    println!("│  └─ Total Data: {:.2} MB", total_bytes as f64 / 1_048_576.0);
                    
                    println!("├─ Protocol Distribution:");
                    for (proto, count) in &protocol_stats {
                        let percentage = (*count as f64 / packet_count as f64) * 100.0;
                        println!("│  ├─ {:<6}: {:>5} ({:.1}%)", proto, count, percentage);
                    }
                    
                    println!("├─ Packet Sizes:");
                    for (size, count) in &size_distribution {
                        let percentage = (*count as f64 / packet_count as f64) * 100.0;
                        println!("│  ├─ {:<20}: {:>5} ({:.1}%)", size, count, percentage);
                    }
                    
                    println!("├─ Health Metrics:");
                    println!("│  ├─ Capture Health: {:.1}%", capture_health);
                    println!("│  └─ Dropped Packets: {} ({:.2}%)", 
                        dropped_packets,
                        (dropped_packets as f64 / packet_count as f64) * 100.0);
                    
                    println!("└─ System Status:");
                    println!("   ├─ Uptime: {:.1} seconds", 
                        std::time::Instant::now().duration_since(last_packet_time).as_secs_f64());
                    println!("   └─ Memory Usage: {} packets in buffer", 
                        packets_since_last_stats);
                    
                    packets_since_last_stats = 0;
                    last_stats_time = std::time::Instant::now();
                }
            }
            Err(e) => {
                eprintln!("\n[!] Error reading packet: {}", e);
                dropped_packets += 1;
                
                if last_packet_time.elapsed().as_secs() > 10 {
                    println!("\n[!] Warning: No packets captured in the last 10 seconds");
                    println!("    Possible issues:");
                    println!("    - Interface in wrong mode");
                    println!("    - Insufficient permissions");
                    println!("    - No traffic on interface");
                    println!("    - Firewall blocking");
                    last_packet_time = std::time::Instant::now();
                }
                
                // Small sleep to prevent CPU spinning on errors
                std::thread::sleep(std::time::Duration::from_millis(1));
                continue;
            }
        }
    }
    
    // Final statistics
    println!("\n[Final Capture Statistics]");
    println!("├─ Total Packets Processed: {}", packet_count);
    println!("├─ Total Dropped Packets: {}", dropped_packets);
    println!("└─ Total Runtime: {:.1} seconds", std::time::Instant::now().duration_since(last_packet_time).as_secs_f64());
    
    println!("\n[*] Capture stopped. Exiting.");
    Ok(())
}

fn process_tcp_packet(
    ipv4: &Ipv4Packet,
    tcp: &TcpPacket,
    writer: &mut csv::Writer<std::fs::File>,
) -> Result<()> {
    let now = SystemTime::now();
    let src_ip = ipv4.get_source();
    let dst_ip = ipv4.get_destination();
    let src_port = tcp.get_source();
    let dst_port = tcp.get_destination();
    let protocol_num = 6;  // TCP is protocol 6
    let flow_key = format!("{}:{}-{}:{}-{}", src_ip, src_port, dst_ip, dst_port, protocol_num);
    let reverse_key = format!("{}:{}-{}:{}-{}", dst_ip, dst_port, src_ip, src_port, protocol_num);
    
    let mut flow_table = FLOW_TABLE.lock()
        .map_err(|e| DDoSError::LockError(format!("Failed to acquire flow table lock: {}", e)))?;
    
    // Check if this is a reverse flow
    let (key, is_reverse) = if flow_table.contains_key(&flow_key) {
        (flow_key, false)
    } else if flow_table.contains_key(&reverse_key) {
        (reverse_key, true)
    } else {
        (flow_key, false)
    };
    
    let flow = flow_table.entry(key.clone()).or_insert_with(|| FlowTracker {
        start_time: now,
        fwd_packets: VecDeque::new(),
        bwd_packets: VecDeque::new(),
        last_fwd_time: None,
        last_bwd_time: None,
        init_fwd_win: None,
        init_bwd_win: None,
        src_ip: IpAddr::V4(src_ip),
        dst_ip: IpAddr::V4(dst_ip),
        src_port,
        dst_port,
        protocol: protocol_num,
        last_prediction: None,
        prediction_count: 0,
    });

    let packet_data = PacketData {
        timestamp: now,
        size: ipv4.get_total_length() as usize,
        tcp_flags: Some(tcp.get_flags()),
        header_len: (tcp.get_data_offset() as usize) * 4,
        payload_len: tcp.payload().len(),
    };

    // Determine direction
    let is_forward = !is_reverse;
    if is_forward {
        flow.fwd_packets.push_back(packet_data);
        flow.last_fwd_time = Some(now);
        if flow.init_fwd_win.is_none() {
            flow.init_fwd_win = Some(tcp.get_window());
        }
    } else {
        flow.bwd_packets.push_back(packet_data);
        flow.last_bwd_time = Some(now);
        if flow.init_bwd_win.is_none() {
            flow.init_bwd_win = Some(tcp.get_window());
        }
    }

    // Calculate features
    let mut features = calculate_features(&flow);
    
    // Save original IPs
    let orig_src_ip = features.src_ip.clone();
    let orig_dst_ip = features.dst_ip.clone();
    
    // Check if this is HTTP traffic
    let is_http = features.src_port == 80 || features.dst_port == 80;

    // Encode categorical features before prediction
    if let Err(e) = model_predictor::apply_label_encoders(&mut features, "unified_ddos_best_model_metadata.pkl") {
        eprintln!("Label encoding error: {}", e);
    }

    // Get prediction
    if let Ok(predictor_guard) = MODEL_PREDICTOR.lock() {
        if let Some(predictor) = predictor_guard.as_ref() {
            match predictor.predict(&features) {
                Ok((attack_type, confidence)) => {
                    // Print prediction with color
                    let prediction_color = if attack_type != "BENIGN" { "\x1b[31m" } else { "\x1b[32m" };
                    println!("\n\x1b[36m=== Packet Analysis ===\x1b[0m");
                    println!("Source IP: \x1b[33m{}\x1b[0m", orig_src_ip);
                    println!("Destination IP: \x1b[33m{}\x1b[0m", orig_dst_ip);
                    
                    // Identify common service ports
                    let service_name = match (flow.src_port, flow.dst_port) {
                        (80, _) | (_, 80) => " (HTTP)",
                        (443, _) | (_, 443) => " (HTTPS)",
                        (22, _) | (_, 22) => " (SSH)",
                        (53, _) | (_, 53) => " (DNS)",
                        (21, _) | (_, 21) => " (FTP)",
                        (3306, _) | (_, 3306) => " (MySQL)",
                        (27017, _) | (_, 27017) => " (MongoDB)",
                        _ => ""
                    };
                    
                    println!("Protocol: \x1b[33m{}{}\x1b[0m", features.protocol, service_name);
                    println!("Ports: \x1b[33m{} → {}\x1b[0m", flow.src_port, flow.dst_port);
                    println!("Flow Rate: \x1b[33m{:.2} pkts/sec\x1b[0m", features.flow_pkts_s);
                    println!("Prediction: {}{}\\x1b[0m (Confidence: {:.2}%)", 
                        prediction_color, attack_type, confidence * 100.0);
                    
                    // Enhanced DDoS detection for all protocols
                    let threshold = match (flow.src_port, flow.dst_port) {
                        // Adjust thresholds based on protocol
                        (80, _) | (_, 80) => 100.0,    // HTTP
                        (443, _) | (_, 443) => 100.0,  // HTTPS
                        (53, _) | (_, 53) => 200.0,    // DNS higher threshold
                        _ => 150.0                      // Default threshold
                    };

                    if features.flow_pkts_s > threshold {
                        println!("\n\x1b[31m⚠️  Potential DDoS Attack Indicators:\x1b[0m");
                        println!("   • High packet rate: {:.2} packets/sec", features.flow_pkts_s);
                        println!("   • Source IP: {}", orig_src_ip);
                        
                        // Protocol-specific checks
                        match (flow.src_port, flow.dst_port) {
                            (80, _) | (_, 80) | (443, _) | (_, 443) => {
                                if features.syn_flag_cnt > 5 {
                                    println!("   • High SYN count: {} (possible SYN flood)", features.syn_flag_cnt);
                                }
                            },
                            (53, _) | (_, 53) => {
                                if features.flow_byts_s > 10000.0 {
                                    println!("   • High DNS traffic volume: {:.2} bytes/sec", features.flow_byts_s);
                                }
                            },
                            _ => {
                                if features.syn_flag_cnt > 3 {
                                    println!("   • Elevated SYN count: {}", features.syn_flag_cnt);
                                }
                            }
                        }
                        
                        // Common indicators for all protocols
                        if features.flow_duration < 1.0 && features.tot_fwd_pkts > 10 {
                            println!("   • Burst pattern: {} packets in {:.2}s", 
                                features.tot_fwd_pkts, features.flow_duration);
                        }
                        if features.fwd_pkt_len_std < 1.0 && features.tot_fwd_pkts > 5 {
                            println!("   • Uniform packet size detected (possible automated attack)");
                        }
                    }

                    // Check for potential DDoS if it's an attack
                    if attack_type != "BENIGN" {
                        if let Ok(mut detector) = DDOS_DETECTOR.lock() {
                            if let Some(alert) = detector.check_ip(&orig_src_ip, &attack_type) {
                                println!("\n{}\n", alert);
                            }
                        } else {
                            eprintln!("Failed to acquire DDoS detector lock");
                        }
                    }
                    
                    println!("\x1b[36m{}\x1b[0m", "-".repeat(50));
                }
                Err(e) => eprintln!("Prediction error: {}", e),
            }
        }
    }

    // Make prediction every 10 packets or if it's a new flow
    let total_packets = flow.fwd_packets.len() + flow.bwd_packets.len();
    if total_packets % 10 == 0 || flow.last_prediction.is_none() {
        if let Ok(model_guard) = MODEL_PREDICTOR.lock() {
            if let Some(ref predictor) = *model_guard {
                match predictor.predict(&features) {
                Ok((prediction, confidence)) => {
                    features.label = prediction.clone();
                    flow.last_prediction = Some((prediction.clone(), confidence));
                    flow.prediction_count += 1;
                    // Enhanced DDoS and Slowloris detection
                    let is_ddos = prediction.to_lowercase().contains("ddos") || 
                                 prediction.to_lowercase().contains("attack");
                    
                    // Slowloris pattern detection
                    let is_slowloris = features.flow_duration < 0.01 && // Very short flows
                        features.tot_fwd_pkts == 1 && // Single packet flows
                        features.tot_bwd_pkts == 0 && // No response packets
                        features.flow_byts_s > 100000.0 && // High byte rate
                        features.protocol == 6; // TCP protocol
                    
                    if is_ddos || is_slowloris {
                        let attack_type = if is_slowloris {
                            "SLOWLORIS"
                        } else {
                            &prediction
                        };
                        
                        println!("\n\x1b[31m⚠️  POTENTIAL {} ATTACK DETECTED!\x1b[0m", attack_type);
                        println!("   Flow: {}:{} -> {}:{}", 
                                orig_src_ip, features.src_port,
                                orig_dst_ip, features.dst_port);
                        println!("   Prediction: {} (Confidence: {:.2}%)", 
                                attack_type, confidence * 100.0);
                        println!("   Flow Stats:");
                        println!("     - Packets: {} forward, {} backward", 
                                features.tot_fwd_pkts, features.tot_bwd_pkts);
                        println!("     - Bytes/sec: {:.2}", features.flow_byts_s);
                        println!("     - Flow Duration: {:.6}s", features.flow_duration);
                    }
                }
                Err(e) => {
                    eprintln!("Prediction error: {}", e);
                    features.label = "Error".to_string();
                }
            }
        }
    } else if let Some((ref last_pred, _)) = flow.last_prediction {
        features.label = last_pred.clone();
    }

    // Restore original IPs before saving to CSV
    features.src_ip = orig_src_ip;
    features.dst_ip = orig_dst_ip;
    writer.serialize(&features)?;
    writer.flush()?;

    // Print normal flow progress and check for HTTP DDoS patterns
    if total_packets % 20 == 0 || is_http {
        println!("TCP Flow: {}:{} -> {}:{} [Fwd: {}, Bwd: {}, Pred: {}]{}",
            features.src_ip, features.src_port,
            features.dst_ip, features.dst_port,
            features.tot_fwd_pkts, features.tot_bwd_pkts,
            features.label,
            if is_http { " [HTTP Traffic]" } else { "" });
            
        // Additional DDoS detection for HTTP
        if is_http && features.flow_pkts_s > 100.0 {  // More than 100 packets per second
            println!("⚠️  Potential HTTP DDoS Attack Detected!");
            println!("   Flow Rate: {:.2} packets/sec", features.flow_pkts_s);
            println!("   Source IP: {}", features.src_ip);
        }
    }

    Ok(())
}

fn process_udp_packet(
    ipv4: &Ipv4Packet,
    udp: &UdpPacket,
    writer: &mut csv::Writer<std::fs::File>,
) -> Result<()> {
    let now = SystemTime::now();
    let src_ip = ipv4.get_source();
    let dst_ip = ipv4.get_destination();
    let src_port = udp.get_source();
    let dst_port = udp.get_destination();
    let protocol_num = 17;  // UDP is protocol 17
    let flow_key = format!("{}:{}-{}:{}-{}", src_ip, src_port, dst_ip, dst_port, protocol_num);
    let reverse_key = format!("{}:{}-{}:{}-{}", dst_ip, dst_port, src_ip, src_port, protocol_num);
    
    let mut flow_table = FLOW_TABLE.lock().unwrap();
    
    let (key, is_reverse) = if flow_table.contains_key(&flow_key) {
        (flow_key, false)
    } else if flow_table.contains_key(&reverse_key) {
        (reverse_key, true)
    } else {
        (flow_key, false)
    };
    
    let flow = flow_table.entry(key.clone()).or_insert_with(|| FlowTracker {
        start_time: now,
        fwd_packets: VecDeque::new(),
        bwd_packets: VecDeque::new(),
        last_fwd_time: None,
        last_bwd_time: None,
        init_fwd_win: None,
        init_bwd_win: None,
        src_ip: IpAddr::V4(src_ip),
        dst_ip: IpAddr::V4(dst_ip),
        src_port,
        dst_port,
        protocol: protocol_num,
        last_prediction: None,
        prediction_count: 0,
    });

    let packet_data = PacketData {
        timestamp: now,
        size: ipv4.get_total_length() as usize,
        tcp_flags: None,
        header_len: 8, // UDP header is always 8 bytes
        payload_len: udp.payload().len(),
    };

    // Determine direction
    let is_forward = !is_reverse;
    if is_forward {
        flow.fwd_packets.push_back(packet_data);
        flow.last_fwd_time = Some(now);
    } else {
        flow.bwd_packets.push_back(packet_data);
        flow.last_bwd_time = Some(now);
    }

    // Calculate features and make prediction
    let mut features = calculate_features(&flow);
    let orig_src_ip = features.src_ip.clone();
    let orig_dst_ip = features.dst_ip.clone();

    // Get protocol-specific packet rate threshold
    let packet_rate_threshold = match (features.src_port, features.dst_port) {
        (53, _) | (_, 53) => 200.0,    // DNS queries - higher threshold
        (123, _) | (_, 123) => 50.0,   // NTP traffic
        (1900, _) | (_, 1900) => 30.0, // SSDP traffic
        (137, _) | (_, 137) => 40.0,   // NetBIOS
        (389, _) | (_, 389) => 60.0,   // LDAP
        (11211, _) | (_, 11211) => 45.0, // Memcached
        _ => 100.0,                    // Default threshold
    };

    // Attack patterns are checked in the match statement during prediction

    // Encode categorical features before prediction
    if let Err(e) = model_predictor::apply_label_encoders(&mut features, "unified_ddos_best_model_metadata.pkl") {
        eprintln!("Label encoding error: {}", e);
    }

    let total_packets = flow.fwd_packets.len() + flow.bwd_packets.len();
    if total_packets % 15 == 0 || flow.last_prediction.is_none() {
        if let Some(ref predictor) = *MODEL_PREDICTOR.lock().unwrap() {
            match predictor.predict(&mut features) {
                Ok((prediction, confidence)) => {
                    features.label = prediction.clone();
                    flow.last_prediction = Some((prediction.clone(), confidence));
                    flow.prediction_count += 1;

                    // Specific attack type detection based on model predictions and traffic patterns
                    let attack_type = match prediction.as_str() {
                        "DNS" => {
                            if (features.src_port == 53 || features.dst_port == 53) && 
                               features.bwd_pkt_len_mean > 512.0 {
                                Some(("DNS Amplification", "\x1b[31m"))
                            } else {
                                None
                            }
                        },
                        "NTP" => {
                            if (features.src_port == 123 || features.dst_port == 123) && 
                               features.flow_byts_s > 100000.0 {
                                Some(("NTP Amplification", "\x1b[31m"))
                            } else {
                                None
                            }
                        },
                        "HTTP" => {
                            if features.protocol == 6 && 
                               (features.src_port == 80 || features.dst_port == 80) {
                                Some(("HTTP Flood", "\x1b[33m"))
                            } else {
                                None
                            }
                        },
                        "LDAP" => {
                            if (features.src_port == 389 || features.dst_port == 389) && 
                               features.bwd_pkt_len_mean > 1000.0 {
                                Some(("LDAP Amplification", "\x1b[31m"))
                            } else {
                                None
                            }
                        },
                        "MSSQL" => {
                            if (features.src_port == 1433 || features.dst_port == 1433 ||
                                features.protocol == 90) && // MSSQL TDS protocol
                               features.flow_byts_s > 100000.0 && // High byte rate
                               features.tot_fwd_pkts >= 1 && // At least one forward packet
                               features.fwd_pkt_len_mean > 1000.0 // Large packets
                            {
                                Some(("MSSQL Attack", "\x1b[35m"))
                            } else {
                                None
                            }
                        },
                        "NetBIOS" => {
                            if features.src_port == 137 || features.dst_port == 137 && 
                               features.flow_pkts_s > 40.0 {
                                Some(("NetBIOS Attack", "\x1b[33m"))
                            } else {
                                None
                            }
                        },
                        "Portmap" => {
                            if features.src_port == 111 || features.dst_port == 111 {
                                Some(("Portmap Attack", "\x1b[35m"))
                            } else {
                                None
                            }
                        },
                        "Slowloris" => {
                            if features.protocol == 6 && 
                               (features.src_port == 80 || features.dst_port == 80 || 
                                features.src_port == 443 || features.dst_port == 443) &&
                               // Slowloris characteristics:
                               features.flow_duration < 1.0 && // Short initial connections
                               features.fwd_pkt_len_mean < 200.0 && // Small packets
                               features.flow_pkts_s < 100.0 && // Lower packet rate
                               features.tot_fwd_pkts <= 2 // Few packets per flow
                            {
                                Some(("Slowloris Attack", "\x1b[36m"))
                            } else {
                                None
                            }
                        },
                        "RECURSIVE_GET" => {
                            if features.protocol == 6 && 
                               (features.src_port == 80 || features.dst_port == 80) &&
                               features.flow_pkts_s > 50.0 {
                                Some(("Recursive GET Attack", "\x1b[33m"))
                            } else {
                                None
                            }
                        },
                        "SLOW_POST" => {
                            if features.protocol == 6 && 
                               (features.src_port == 80 || features.dst_port == 80) &&
                               features.flow_duration > 8.0 &&
                               features.fwd_pkt_len_mean < 200.0 {
                                Some(("Slow POST Attack", "\x1b[36m"))
                            } else {
                                None
                            }
                        },
                        "SYN" => {
                            if features.protocol == 6 && 
                               features.syn_flag_cnt > 0 &&
                               features.flow_pkts_s > 100.0 {
                                Some(("SYN Flood Attack", "\x1b[31m"))
                            } else {
                                None
                            }
                        },
                        "UDP" | "UDPLag" => {
                            if features.protocol == 17 && 
                               features.flow_pkts_s > packet_rate_threshold {
                                Some(("UDP Flood Attack", "\x1b[31m"))
                            } else {
                                None
                            }
                        },
                        _ => None
                    };

                    // Attack detection patterns are now handled in the match statement above

                    if let Some((attack_name, color)) = attack_type {
                        // Print attack detection alert with specific details
                        println!("\n{}⚠️  {} Detected!\x1b[0m", color, attack_name);
                        
                        // Basic flow information
                        println!("   Flow Details:");
                        println!("   ├─ Protocol: {}{}", 
                            if features.protocol == 6 { "TCP" } else { "UDP" },
                            match (features.src_port, features.dst_port) {
                                (80, _) | (_, 80) => " (HTTP)",
                                (443, _) | (_, 443) => " (HTTPS)",
                                (53, _) | (_, 53) => " (DNS)",
                                (123, _) | (_, 123) => " (NTP)",
                                (389, _) | (_, 389) => " (LDAP)",
                                (1433, _) | (_, 1433) => " (MSSQL)",
                                (137, _) | (_, 137) => " (NetBIOS)",
                                (111, _) | (_, 111) => " (Portmap)",
                                _ => ""
                            }
                        );
                        println!("   ├─ Source: {}:{}", orig_src_ip, features.src_port);
                        println!("   └─ Destination: {}:{}", orig_dst_ip, features.dst_port);
                        
                        // Attack-specific metrics
                        println!("   Attack Metrics:");
                        println!("   ├─ Packet Rate: {:.2} pkts/sec", features.flow_pkts_s);
                        println!("   ├─ Byte Rate: {:.2} bytes/sec", features.flow_byts_s);
                        println!("   ├─ Flow Duration: {:.2}s", features.flow_duration);
                        println!("   ├─ Packets: {} forward, {} backward", 
                            features.tot_fwd_pkts, features.tot_bwd_pkts);
                        println!("   ├─ Avg Packet Size: {:.2} bytes", features.pkt_len_mean);
                        println!("   └─ Inter-arrival Time: {:.3}s", features.fwd_iat_mean);

                        // Model confidence
                        println!("   Model Confidence: {:.2}%", confidence * 100.0);
                        // Protocol-specific warnings based on packet patterns
                        let protocol_warning = match (features.protocol, features.src_port, features.dst_port) {
                            (17, 53, _) | (17, _, 53) if features.flow_pkts_s > 200.0 => 
                                Some("High DNS query rate detected - Possible DNS amplification attack"),
                            (17, 123, _) | (17, _, 123) if features.flow_byts_s > 10000.0 => 
                                Some("High NTP traffic volume - Possible NTP amplification attack"),
                            (17, 1900, _) | (17, _, 1900) if features.pkt_len_mean > 1000.0 => 
                                Some("Large SSDP packets detected - Possible SSDP amplification attack"),
                            _ => None
                        };

                        // Print any protocol-specific warnings
                        if let Some(warning) = protocol_warning {
                            println!("   \x1b[33m⚠ {}\x1b[0m", warning);
                        }

                        println!("\x1b[36m{}\x1b[0m", "-".repeat(50));
                    }
                }
                Err(e) => {
                    eprintln!("Prediction error: {}", e);
                    features.label = "Error".to_string();
                }
            }
        }
    } else if let Some((ref last_pred, _)) = flow.last_prediction {
        features.label = last_pred.clone();
    }

    // Restore original IPs before saving to CSV
    features.src_ip = orig_src_ip;
    features.dst_ip = orig_dst_ip;
    writer.serialize(&features)?;
    writer.flush()?;

    // Print normal flow progress
    if total_packets % 25 == 0 {
        println!("UDP Flow: {}:{} -> {}:{} [Fwd: {}, Bwd: {}, Pred: {}]",
            features.src_ip, features.src_port,
            features.dst_ip, features.dst_port,
            features.tot_fwd_pkts, features.tot_bwd_pkts,
            features.label);
    }

    Ok(())
}

fn process_generic_packet(
    ipv4: &Ipv4Packet,
    protocol: pnet::packet::ip::IpNextHeaderProtocol,
    writer: &mut csv::Writer<std::fs::File>,
) -> Result<()> {
    let now = SystemTime::now();
    let src_ip = ipv4.get_source();
    let dst_ip = ipv4.get_destination();
    let protocol_num = protocol.0 as i64;  // Extract the raw protocol number
    let flow_key = format!("{}:0-{}:0-{}", src_ip, dst_ip, protocol_num);
    let reverse_key = format!("{}:0-{}:0-{}", dst_ip, src_ip, protocol_num);
    
    let mut flow_table = FLOW_TABLE.lock().unwrap();
    
    let (key, is_reverse) = if flow_table.contains_key(&flow_key) {
        (flow_key, false)
    } else if flow_table.contains_key(&reverse_key) {
        (reverse_key, true)
    } else {
        (flow_key, false)
    };
    
    let flow = flow_table.entry(key.clone()).or_insert_with(|| FlowTracker {
        start_time: now,
        fwd_packets: VecDeque::new(),
        bwd_packets: VecDeque::new(),
        last_fwd_time: None,
        last_bwd_time: None,
        init_fwd_win: None,
        init_bwd_win: None,
        src_ip: IpAddr::V4(src_ip),
        dst_ip: IpAddr::V4(dst_ip),
        src_port: 0,
        dst_port: 0,
        protocol: protocol_num,
        last_prediction: None,
        prediction_count: 0,
    });

    let packet_data = PacketData {
        timestamp: now,
        size: ipv4.get_total_length() as usize,
        tcp_flags: None,
        header_len: ipv4.get_header_length() as usize,
        payload_len: ipv4.payload().len(),
    };

    // Determine direction
    let is_forward = !is_reverse;
    if is_forward {
        flow.fwd_packets.push_back(packet_data);
        flow.last_fwd_time = Some(now);
    } else {
        flow.bwd_packets.push_back(packet_data);
        flow.last_bwd_time = Some(now);
    }

    // Calculate features and make prediction
    let mut features = calculate_features(&flow);
    let orig_src_ip = features.src_ip.clone();
    let orig_dst_ip = features.dst_ip.clone();

    // Protocol-specific thresholds and detection
    let (protocol_name, base_threshold) = match protocol_num {
        1 => ("ICMP", 50.0),      // ICMP has lower normal traffic rates
        47 => ("GRE", 150.0),     // GRE tunnel traffic
        50 => ("ESP", 200.0),     // IPSec encrypted traffic
        51 => ("AH", 200.0),      // IPSec authentication
        58 => ("ICMPv6", 50.0),   // ICMPv6 traffic
        _ => ("Unknown", 100.0),   // Default threshold for other protocols
    };

    // Encode categorical features before prediction
    if let Err(e) = model_predictor::apply_label_encoders(&mut features, "unified_ddos_best_model_metadata.pkl") {
        eprintln!("Label encoding error: {}", e);
    }

    let total_packets = flow.fwd_packets.len() + flow.bwd_packets.len();
    if total_packets % 20 == 0 || flow.last_prediction.is_none() {
        if let Some(ref predictor) = *MODEL_PREDICTOR.lock().unwrap() {
            match predictor.predict(&mut features) {
                Ok((prediction, confidence)) => {
                    features.label = prediction.clone();
                    flow.last_prediction = Some((prediction.clone(), confidence));
                    flow.prediction_count += 1;

                    // Enhanced detection logic
                    let is_attack = prediction.to_lowercase().contains("ddos") || 
                                  prediction.to_lowercase().contains("attack");
                    let high_rate = features.flow_pkts_s > base_threshold;
                    let burst_pattern = features.flow_duration < 1.0 && features.tot_fwd_pkts > 20;
                    
                    if is_attack || high_rate || burst_pattern {
                        println!("\n\x1b[31m⚠️  Potential {} DDoS Attack Detected!\x1b[0m", protocol_name);
                        println!("   Flow: {} → {}", orig_src_ip, orig_dst_ip);
                        println!("   Protocol: {} ({})", protocol_name, protocol_num);
                        println!("   Packet Rate: {:.2} pkts/sec (Threshold: {:.2})", 
                            features.flow_pkts_s, base_threshold);
                        println!("   Total Packets: {} (Fwd: {}, Bwd: {})",
                            total_packets, features.tot_fwd_pkts, features.tot_bwd_pkts);
                        println!("   Flow Duration: {:.2}s", features.flow_duration);
                        println!("   Model Prediction: {} (Confidence: {:.2}%)", 
                            prediction, confidence * 100.0);

                        // Protocol-specific warnings
                        if protocol_num == 1 && features.flow_pkts_s > 100.0 {
                            println!("   \x1b[33m⚠ High ICMP rate - Possible ICMP flood attack\x1b[0m");
                        }
                        if burst_pattern {
                            println!("   \x1b[33m⚠ Burst pattern detected - Possible flood attack\x1b[0m");
                        }
                        if features.pkt_len_std < 1.0 && total_packets > 10 {
                            println!("   \x1b[33m⚠ Uniform packet size - Possible automated attack\x1b[0m");
                        }
                        println!("\x1b[36m{}\x1b[0m", "-".repeat(50));
                    }
                }
                Err(e) => {
                    eprintln!("Prediction error: {}", e);
                    features.label = "Error".to_string();
                }
            }
        }
    } else if let Some((ref last_pred, _)) = flow.last_prediction {
        features.label = last_pred.clone();
    }

    // Restore original IPs before saving to CSV
    features.src_ip = orig_src_ip;
    features.dst_ip = orig_dst_ip;
    writer.serialize(&features)?;
    writer.flush()?;

    Ok(())
}

fn calculate_features(flow: &FlowTracker) -> FlowFeatures {
    let mut features = FlowFeatures::default();
    
    // Basic 5-tuple
    features.src_ip = flow.src_ip.to_string();
    features.dst_ip = flow.dst_ip.to_string();
    features.src_port = flow.src_port;
    features.dst_port = flow.dst_port;
    features.protocol = flow.protocol;
    features.timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S%.3f").to_string();
    
    // Basic packet counts
    features.tot_fwd_pkts = flow.fwd_packets.len() as u32;
    features.tot_bwd_pkts = flow.bwd_packets.len() as u32;
    
    // Calculate flow duration
    let current_time = SystemTime::now();
    features.flow_duration = current_time
        .duration_since(flow.start_time)
        .unwrap_or_default()
        .as_secs_f64();
    
    // Calculate packet lengths
    let fwd_lengths: Vec<u32> = flow.fwd_packets.iter().map(|p| p.size as u32).collect();
    let bwd_lengths: Vec<u32> = flow.bwd_packets.iter().map(|p| p.size as u32).collect();
    let all_lengths: Vec<u32> = fwd_lengths.iter().chain(bwd_lengths.iter()).copied().collect();
    
    // Forward packet statistics
    if !fwd_lengths.is_empty() {
        features.fwd_pkt_len_max = *fwd_lengths.iter().max().unwrap_or(&0);
        features.fwd_pkt_len_min = *fwd_lengths.iter().min().unwrap_or(&0);
        features.fwd_pkt_len_mean = fwd_lengths.iter().sum::<u32>() as f64 / fwd_lengths.len() as f64;
        features.fwd_pkt_len_std = calculate_std_dev(&fwd_lengths, features.fwd_pkt_len_mean);
        features.totlen_fwd_pkts = fwd_lengths.iter().sum();
    }
    
    // Backward packet statistics
    if !bwd_lengths.is_empty() {
        features.bwd_pkt_len_max = *bwd_lengths.iter().max().unwrap_or(&0);
        features.bwd_pkt_len_min = *bwd_lengths.iter().min().unwrap_or(&0);
        features.bwd_pkt_len_mean = bwd_lengths.iter().sum::<u32>() as f64 / bwd_lengths.len() as f64;
        features.bwd_pkt_len_std = calculate_std_dev(&bwd_lengths, features.bwd_pkt_len_mean);
        features.totlen_bwd_pkts = bwd_lengths.iter().sum();
    }
    
    // Overall packet statistics
    if !all_lengths.is_empty() {
        features.pkt_len_max = *all_lengths.iter().max().unwrap_or(&0);
        features.pkt_len_min = *all_lengths.iter().min().unwrap_or(&0);
        features.pkt_len_mean = all_lengths.iter().sum::<u32>() as f64 / all_lengths.len() as f64;
        features.pkt_len_std = calculate_std_dev(&all_lengths, features.pkt_len_mean);
        features.pkt_len_var = features.pkt_len_std * features.pkt_len_std;
        features.pkt_size_avg = features.pkt_len_mean;
    }
    
    // Calculate rates
    if features.flow_duration > 0.0 {
        features.flow_byts_s = (features.totlen_fwd_pkts + features.totlen_bwd_pkts) as f64 / features.flow_duration;
        features.flow_pkts_s = (features.tot_fwd_pkts + features.tot_bwd_pkts) as f64 / features.flow_duration;
        features.fwd_pkts_s = features.tot_fwd_pkts as f64 / features.flow_duration;
        features.bwd_pkts_s = features.tot_bwd_pkts as f64 / features.flow_duration;
    }
    
    // Calculate header lengths
    features.fwd_header_len = flow.fwd_packets.iter()
        .map(|p| p.header_len as u32)
        .sum();
    features.bwd_header_len = flow.bwd_packets.iter()
        .map(|p| p.header_len as u32)
        .sum();
    
    // Calculate active data packets (packets with payload)
    features.fwd_act_data_pkts = flow.fwd_packets.iter()
        .filter(|p| p.payload_len > 0)
        .count() as u32;
    
    // Calculate Inter-Arrival Times (IAT)
    calculate_iat_features(&flow.fwd_packets, &flow.bwd_packets, &mut features);
    
    // Calculate TCP flags if applicable
    if flow.protocol == 6 {
        calculate_tcp_flags(&flow.fwd_packets, &flow.bwd_packets, &mut features);
    }
    
    // Calculate window sizes
    features.init_fwd_win_byts = flow.init_fwd_win.unwrap_or(0);
    features.init_bwd_win_byts = flow.init_bwd_win.unwrap_or(0);
    
    // Calculate bulk and segment features
    calculate_bulk_features(&flow.fwd_packets, &flow.bwd_packets, &mut features);
    
    // Calculate subflow features (same as flow for single flow)
    features.subflow_fwd_pkts = features.tot_fwd_pkts;
    features.subflow_bwd_pkts = features.tot_bwd_pkts;
    features.subflow_fwd_byts = features.totlen_fwd_pkts;
    features.subflow_bwd_byts = features.totlen_bwd_pkts;
    
    // Calculate ratio features
    if features.totlen_fwd_pkts > 0 {
        features.down_up_ratio = features.totlen_bwd_pkts as f64 / features.totlen_fwd_pkts as f64;
    }
    
    // Calculate segment size features
    if features.tot_fwd_pkts > 0 {
        features.fwd_seg_size_avg = features.totlen_fwd_pkts as f64 / features.tot_fwd_pkts as f64;
        let fwd_payload_sizes: Vec<u32> = flow.fwd_packets.iter()
            .map(|p| p.payload_len as u32)
            .filter(|&size| size > 0)
            .collect();
        if !fwd_payload_sizes.is_empty() {
            features.fwd_seg_size_min = *fwd_payload_sizes.iter().min().unwrap_or(&0);
        }
    }
    
    if features.tot_bwd_pkts > 0 {
        features.bwd_seg_size_avg = features.totlen_bwd_pkts as f64 / features.tot_bwd_pkts as f64;
    }
    
    features
}

fn calculate_std_dev(values: &[u32], mean: f64) -> f64 {
    if values.len() <= 1 {
        return 0.0;
    }
    
    let variance = values.iter()
        .map(|&x| {
            let diff = x as f64 - mean;
            diff * diff
        })
        .sum::<f64>() / (values.len() - 1) as f64;
    
    variance.sqrt()
}

fn calculate_iat_features(
    fwd_packets: &VecDeque<PacketData>,
    bwd_packets: &VecDeque<PacketData>,
    features: &mut FlowFeatures,
) {
    // Calculate forward IAT
    let fwd_iats = calculate_inter_arrival_times(fwd_packets);
    if !fwd_iats.is_empty() {
        features.fwd_iat_tot = fwd_iats.iter().sum();
        features.fwd_iat_max = fwd_iats.iter().fold(0.0, |a, &b| a.max(b));
        features.fwd_iat_min = fwd_iats.iter().fold(f64::MAX, |a, &b| a.min(b));
        features.fwd_iat_mean = features.fwd_iat_tot / fwd_iats.len() as f64;
        features.fwd_iat_std = calculate_std_dev_f64(&fwd_iats, features.fwd_iat_mean);
    }
    
    // Calculate backward IAT
    let bwd_iats = calculate_inter_arrival_times(bwd_packets);
    if !bwd_iats.is_empty() {
        features.bwd_iat_tot = bwd_iats.iter().sum();
        features.bwd_iat_max = bwd_iats.iter().fold(0.0, |a, &b| a.max(b));
        features.bwd_iat_min = bwd_iats.iter().fold(f64::MAX, |a, &b| a.min(b));
        features.bwd_iat_mean = features.bwd_iat_tot / bwd_iats.len() as f64;
        features.bwd_iat_std = calculate_std_dev_f64(&bwd_iats, features.bwd_iat_mean);
    }
    
    // Calculate flow IAT (combined)
    let mut all_packets: Vec<&PacketData> = fwd_packets.iter().chain(bwd_packets.iter()).collect();
    all_packets.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
    
    let flow_iats = calculate_inter_arrival_times_from_sorted(&all_packets);
    if !flow_iats.is_empty() {
        features.flow_iat_max = flow_iats.iter().fold(0.0, |a, &b| a.max(b));
        features.flow_iat_min = flow_iats.iter().fold(f64::MAX, |a, &b| a.min(b));
        features.flow_iat_mean = flow_iats.iter().sum::<f64>() / flow_iats.len() as f64;
        features.flow_iat_std = calculate_std_dev_f64(&flow_iats, features.flow_iat_mean);
    }
}

fn calculate_inter_arrival_times(packets: &VecDeque<PacketData>) -> Vec<f64> {
    let mut iats = Vec::new();
    
    for window in packets.iter().collect::<Vec<_>>().windows(2) {
        if let [prev, curr] = window {
            if let Ok(duration) = curr.timestamp.duration_since(prev.timestamp) {
                iats.push(duration.as_secs_f64());
            }
        }
    }
    
    iats
}

fn calculate_inter_arrival_times_from_sorted(packets: &[&PacketData]) -> Vec<f64> {
    let mut iats = Vec::new();
    
    for window in packets.windows(2) {
        if let [prev, curr] = window {
            if let Ok(duration) = curr.timestamp.duration_since(prev.timestamp) {
                iats.push(duration.as_secs_f64());
            }
        }
    }
    
    iats
}

fn calculate_std_dev_f64(values: &[f64], mean: f64) -> f64 {
    if values.len() <= 1 {
        return 0.0;
    }
    
    let variance = values.iter()
        .map(|&x| {
            let diff = x - mean;
            diff * diff
        })
        .sum::<f64>() / (values.len() - 1) as f64;
    
    variance.sqrt()
}

fn verify_packet(ipv4: &Ipv4Packet) -> bool {
    // Verify IP header checksum
    let header_len = ipv4.get_header_length() as usize * 4;
    if header_len < 20 || header_len > ipv4.packet().len() {
        return false;
    }

    // Verify total length
    let total_length = ipv4.get_total_length() as usize;
    if total_length < header_len || total_length > ipv4.packet().len() {
        return false;
    }

    // Verify IP version
    if ipv4.get_version() != 4 {
        return false;
    }

    // Verify source and destination addresses
    let src_ip = ipv4.get_source();
    let dst_ip = ipv4.get_destination();
    
    // Check for invalid IP addresses
    if src_ip.is_unspecified() || src_ip.is_broadcast() || 
       dst_ip.is_unspecified() || 
       (src_ip.is_loopback() && !dst_ip.is_loopback()) {
        return false;
    }

    true
}

fn calculate_tcp_flags(
    fwd_packets: &VecDeque<PacketData>,
    bwd_packets: &VecDeque<PacketData>,
    features: &mut FlowFeatures,
) {
    // TCP flag constants
    const FIN: u8 = 0x01;
    const SYN: u8 = 0x02;
    const RST: u8 = 0x04;
    const PSH: u8 = 0x08;
    const ACK: u8 = 0x10;
    const URG: u8 = 0x20;
    const ECE: u8 = 0x40;
    const CWR: u8 = 0x80;
    
    let mut fin_count = 0u8;
    let mut syn_count = 0u8;
    let mut rst_count = 0u8;
    let mut psh_count = 0u8;
    let mut ack_count = 0u8;
    let mut urg_count = 0u8;
    let mut ece_count = 0u8;
    let mut cwr_count = 0u8;
    
    let mut fwd_psh_count = 0u8;
    let mut fwd_urg_count = 0u8;
    let mut bwd_psh_count = 0u8;
    let mut bwd_urg_count = 0u8;

    // Process forward packets
    for packet in fwd_packets {
        if let Some(flags) = packet.tcp_flags {
            if flags & FIN != 0 { fin_count += 1; }
            if flags & SYN != 0 { syn_count += 1; }
            if flags & RST != 0 { rst_count += 1; }
            if flags & PSH != 0 { psh_count += 1; fwd_psh_count += 1; }
            if flags & ACK != 0 { ack_count += 1; }
            if flags & URG != 0 { urg_count += 1; fwd_urg_count += 1; }
            if flags & ECE != 0 { ece_count += 1; }
            if flags & CWR != 0 { cwr_count += 1; }
        }
    }

    // Process backward packets
    for packet in bwd_packets {
        if let Some(flags) = packet.tcp_flags {
            if flags & FIN != 0 { fin_count += 1; }
            if flags & SYN != 0 { syn_count += 1; }
            if flags & RST != 0 { rst_count += 1; }
            if flags & PSH != 0 { psh_count += 1; bwd_psh_count += 1; }
            if flags & ACK != 0 { ack_count += 1; }
            if flags & URG != 0 { urg_count += 1; bwd_urg_count += 1; }
            if flags & ECE != 0 { ece_count += 1; }
            if flags & CWR != 0 { cwr_count += 1; }
        }
    }

    // Update feature struct with collected flags
    features.fin_flag_cnt = fin_count;
    features.syn_flag_cnt = syn_count;
    features.rst_flag_cnt = rst_count;
    features.psh_flag_cnt = psh_count;
    features.ack_flag_cnt = ack_count;
    features.urg_flag_cnt = urg_count;
    features.ece_flag_cnt = ece_count;
    features.cwr_flag_count = cwr_count;
    
    features.fwd_psh_flags = fwd_psh_count;
    features.fwd_urg_flags = fwd_urg_count;
    features.bwd_psh_flags = bwd_psh_count;
    features.bwd_urg_flags = bwd_urg_count;

}

fn calculate_bulk_features(
    fwd_packets: &VecDeque<PacketData>,
    bwd_packets: &VecDeque<PacketData>,
    features: &mut FlowFeatures,
) {
    // Calculate bulk transfer statistics
    let fwd_bulk_packets = fwd_packets.len() as f64;
    let bwd_bulk_packets = bwd_packets.len() as f64;
    
    if fwd_bulk_packets > 0.0 {
        let total_fwd_bytes: u32 = fwd_packets.iter()
            .map(|p| p.payload_len as u32)
            .sum();
        features.fwd_byts_b_avg = total_fwd_bytes as f64 / fwd_bulk_packets;
        features.fwd_pkts_b_avg = fwd_bulk_packets;
        features.fwd_blk_rate_avg = features.fwd_byts_b_avg / features.flow_duration.max(1.0);
    }
    
    if bwd_bulk_packets > 0.0 {
        let total_bwd_bytes: u32 = bwd_packets.iter()
            .map(|p| p.payload_len as u32)
            .sum();
        features.bwd_byts_b_avg = total_bwd_bytes as f64 / bwd_bulk_packets;
        features.bwd_pkts_b_avg = bwd_bulk_packets;
        features.bwd_blk_rate_avg = features.bwd_byts_b_avg / features.flow_duration.max(1.0);
    }
    
    // Calculate active and idle time statistics
    calculate_active_idle_stats(fwd_packets, bwd_packets, features);
}

fn calculate_active_idle_stats(
    fwd_packets: &VecDeque<PacketData>,
    bwd_packets: &VecDeque<PacketData>,
    features: &mut FlowFeatures,
) {
    // Combine all packets and sort by timestamp
    let mut all_packets: Vec<&PacketData> = fwd_packets.iter().chain(bwd_packets.iter()).collect();
    all_packets.sort_by(|a, b| a.timestamp.cmp(&b.timestamp));
    
    if all_packets.len() < 2 {
        return;
    }
    
    const ACTIVE_TIMEOUT: f64 = 1.0; // 1 second timeout for active period
    const IDLE_TIMEOUT: f64 = 5.0;  // 5 second timeout for idle period
    
    let mut active_periods = Vec::new();
    let mut idle_periods = Vec::new();
    let mut current_active_start = all_packets[0].timestamp;
    let mut last_packet_time = all_packets[0].timestamp;
    
    for packet in all_packets.iter().skip(1) {
        if let Ok(idle_time) = packet.timestamp.duration_since(last_packet_time) {
            let idle_secs = idle_time.as_secs_f64();
            
            if idle_secs > ACTIVE_TIMEOUT {
                // End of active period
                if let Ok(active_duration) = last_packet_time.duration_since(current_active_start) {
                    active_periods.push(active_duration.as_secs_f64());
                }
                
                if idle_secs > IDLE_TIMEOUT {
                    idle_periods.push(idle_secs);
                }
                
                current_active_start = packet.timestamp;
            }
        }
        last_packet_time = packet.timestamp;
    }
    
    // Add final active period
    if let Ok(final_active) = last_packet_time.duration_since(current_active_start) {
        active_periods.push(final_active.as_secs_f64());
    }
    
    // Calculate active time statistics
    if !active_periods.is_empty() {
        features.active_max = *active_periods.iter().max_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)).unwrap_or(&0.0);
        features.active_min = *active_periods.iter().min_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)).unwrap_or(&0.0);
        features.active_mean = active_periods.iter().sum::<f64>() / active_periods.len() as f64;
        features.active_std = calculate_std_dev_f64(&active_periods, features.active_mean);
    }
    
    // Calculate idle time statistics
    if !idle_periods.is_empty() {
        features.idle_max = *idle_periods.iter().max_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)).unwrap_or(&0.0);
        features.idle_min = *idle_periods.iter().min_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)).unwrap_or(&0.0);
        features.idle_mean = idle_periods.iter().sum::<f64>() / idle_periods.len() as f64;
        features.idle_std = calculate_std_dev_f64(&idle_periods, features.idle_mean);
    }
    

}